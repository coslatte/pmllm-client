# Client Web Overview: Interface for Music Recommendation System with RAG

This repository contains the web client (pmllm-client) developed with Next.js 16, TypeScript, and Tailwind CSS. It is a graphical interface that acts as a mediator between the user and the backend processing, providing an intuitive experience to interact with a Knowledge-Graph + Retrieval-Augmented Generation (RAG) system based on a language model (to be decided).

## Purpose from the User's Perspective

- **Interactive Chatbot**: A classic chat interface where users send prompts (messages) and receive responses generated by the LLM (language model to be decided) from the backend. Responses include contextual explanations, source citations, and confidence scores.
- **Music Recommendation System**: A dedicated UI section for obtaining personalized recommendations of courses, musical pieces, playlists, and music-related resources, based on the knowledge graph and information retrieval from the backend.
- **Relationship Discovery**: Visualization of connections between musical topics (genres, artists, theoretical concepts) through the interface, leveraging the backend's knowledge graph.

## Architecture from the Client's View

The web client connects via REST API to the backend, which handles:

1. **Processing Backend**:
   - Knowledge Graph (KG) with MusicBrainz data (artists, recordings, genres, etc.)
   - Vector Store (Milvus) for embedding retrieval
   - Generation with Gemma 3 for high-quality responses
   - Orchestration of queries and recommendations

2. **Client Interface**:
   - **Chat Interface**: Sending prompts to the backend and displaying responses with rich formatting (citations, confidence)
   - **Recommendations UI**: Panels to explore music recommendations, with filters and navigation by relationships
   - **User Experience**: Responsive design with **Tailwind CSS v4 exclusively** (no custom CSS), optimized for students, educators, and music professionals

3. **API Endpoints Used**:
   - `/recommend`: For obtaining personalized music recommendations
   - `/connect`: For exploring relationships in the knowledge graph
   - `/ask`: For general queries via chatbot

## Complete System Context

The backend implements a RAG + KG system that uses a language model (to be decided) for generation, without fine-tuning. It employs embeddings and vector stores for retrieval, with Neo4j for the knowledge graph derived from MusicBrainz. The web client is the presentation layer that makes this advanced functionality accessible through a user-friendly interface.

## Key Client Functionalities

- **Chat with the LLM**: Conversation interface for questions about music, theory, recommendations, etc.
- **Interactive Recommendations**: Exploration of courses, similar artists, preference-based playlists
- **Relationship Visualization**: Charts or lists showing connections (e.g., "harmony → counterpoint → orchestration")
- **Session Management**: History of chats and personalized recommendations

This client transforms the backend's power into an accessible tool for music education, professional practice, and music discovery.

## Current Frontend Surface (November 2025)

- **Workspace Shell**: `app/page.tsx` renders `ChatWorkspace`, a client component that orchestrates the fixed header and the two-column layout (dock + primary area) while remaining responsive.
- **Dual Sections**: `SectionNav` lets the user switch between the chat stream and the recommendations panel, while also providing a seed chat list with the ability to create new sessions in place.
- **Theme Persistence**: `ChatHeader` wires the `ThemeToggle` control, persisting the selected mode inside `window.localStorage` (`pmllm-theme`) and syncing it with the CSS variable palette defined in `app/globals.css`.
- **Persona Drawer**: `UserMenu` exposes a collapsible identity card with focus metadata and genre tags sourced from `lib/constants/chat.ts`, reinforcing the personalization story.

## Chat Experience Deep Dive

1. **State + Streaming Simulation**: `useChatSession` owns the conversation array, user input, responder flag, and scroll anchor. The current implementation seeds messages from `lib/constants/chat.ts`, pushes user prompts, and injects a placeholder assistant response after a short timeout so the UI can be exercised without the backend.
2. **Message Rendering**: `MessageList` maps `ChatMessage` entities (defined in `lib/types/chat.ts`) to `MessageBubble` components. Assistant bubbles render confidence badges and citation chips when present so backend metadata is visible to the user.
3. **Composer UX**: `ChatComposer` provides a labeled textarea, disabled submit state while `isResponding` is true, and gradient call-to-action styling aligned with Tailwind v4 tokens. The component emits `handleSubmit` so API wiring can happen centrally inside the hook.
4. **Auto-Scroll**: The hook's `endOfMessagesRef` keeps the chat pinned to the latest exchange, preparing the surface for streaming responses.

## Recommendations Experience

- **Panel Entry Point**: Selecting "Recommendations" in `SectionNav` swaps the main area for `RecommendationsPanel`, which currently renders bilingual copy to highlight the data provenance message.
- **Data Source**: `lib/constants/recommendations.ts` hosts `recommendedAlbums`, a mock list of eight albums typed via `RecommendedAlbum`. Each record combines genre tags, highlights, and recap text that can later be replaced by `/recommend` payloads.
- **Progressive Disclosure**: The panel shows six cards by default and surfaces a "Más recomendaciones" button when more static data is available. The button reveals three additional cards per click, matching the intended incremental loading experience.
- **Card Layout**: `RecommendationCard` standardizes the treatment of recurrence tags, album metadata, and highlight statements, providing a drop-in template for backend-driven playlists.

## Theming, Styling, and Localization Notes

- **Tailwind-Only Styling**: All components rely on Tailwind v4 utility classes and the CSS custom properties defined in `app/globals.css`. No custom CSS files are introduced beyond the theme tokens.
- **Dark Mode Tokens**: `:root[data-theme="dark"]` overrides base colors and enables `color-scheme: dark`, so the UI reacts to both the stored preference and `prefers-color-scheme` when no manual override exists.
- **Localized UI Strings**: Recommendation headlines intentionally demonstrate Spanish marketing copy while the rest of the UI remains in English, ensuring the layout tolerates mixed-language payloads.

## API Integration Checklist

1. **/ask**: Replace the timeout stub inside `useChatSession` with a `fetch` call that streams assistant deltas, populating `confidence` and `citations` from the backend response.
2. **/recommend**: Swap the local `recommendedAlbums` import for a hook that fetches personalized playlists using the active chat context (or user metadata) as the payload.
3. **/connect**: Extend the workspace with an additional SectionNav entry once the graph exploration surface is ready; the layout already anticipates multiple sections.
4. **Error + Loading States**: Surface optimistic toasts or inline alerts in `ChatComposer` and `RecommendationsPanel` to mirror backend latency.

## Documentation Style

- **No emojis in documentation or developer-facing text**: Documentation, README, changelogs, commit messages, code comments, and generated UI strings must not contain emoji characters unless explicitly requested. Keep documentation plain, professional, and searchable.
- English documentation under `docs/` is the technical source of truth; Spanish translations must live in `docs/es_ES/` and be updated in sync when changes are made.
